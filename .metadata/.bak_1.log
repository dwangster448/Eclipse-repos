!SESSION 2023-10-19 15:37:56.136 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/danielwang/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/danielwang/.eclipse_keyring

This is a continuation of log file /Users/danielwang/eclipse-workspace/.metadata/.bak_0.log
Created Time: 2023-10-19 16:29:54.335

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 16:29:54.335
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredNodeBinding(JavadocHover.java:882)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotations(JavadocHover.java:1173)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.addAnnotations(JavadocHover.java:1137)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:745)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 16:29:54.336
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredNodeBinding(JavadocHover.java:882)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotations(JavadocHover.java:1173)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.addAnnotations(JavadocHover.java:1137)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:745)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 16:29:56.109
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import BinarySearchTree.Node;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  public KeyList<T> startPoint;

  public int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (startPoint == null) {
      startPoint = newKey;
    } else if (startPoint.containsKey(key)) {
      return false;
    } else {
      startPoint.addKey(key);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    this.startPoint = (KeyList<T>) startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    @SuppressWarnings("rawtypes")
    Stack toReturn = new Stack();
    if (this.startPoint == null) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else if (this.startPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (startPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 16:29:56.110
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 16:29:56.111
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 16:29:57.763
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import BinarySearchTree.Node;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  public KeyList<T> startPoint;

  public int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (startPoint == null) {
      startPoint = newKey;
    } else if (startPoint.containsKey(key)) {
      return false;
    } else {
      startPoint.addKey(key);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    this.startPoint = (KeyList<T>) startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    @SuppressWarnings("rawtypes")
    Stack toReturn = new Stack();
    if (this.startPoint == null) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else if (this.startPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (startPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 16:29:57.765
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 16:29:57.765
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 16:29:58.773
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import BinarySearchTree.Node;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  public KeyList<T> startPoint;

  public int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (startPoint == null) {
      startPoint = newKey;
    } else if (startPoint.containsKey(key)) {
      return false;
    } else {
      startPoint.addKey(key);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    this.startPoint = (KeyList<T>) startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    @SuppressWarnings("rawtypes")
    Stack toReturn = new Stack();
    if (this.startPoint == null) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else if (this.startPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (startPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 16:29:58.775
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 16:29:58.776
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 16:30:00.177
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import BinarySearchTree.Node;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  public KeyList<T> startPoint;

  public int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (startPoint == null) {
      startPoint = newKey;
    } else if (startPoint.containsKey(key)) {
      return false;
    } else {
      startPoint.addKey(key);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    this.startPoint = (KeyList<T>) startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    @SuppressWarnings("rawtypes")
    Stack toReturn = new Stack();
    if (this.startPoint == null) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else if (this.startPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (startPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 16:30:00.178
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 16:30:00.179
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 16:30:00.206
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import BinarySearchTree.Node;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  public KeyList<T> startPoint;

  public int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (startPoint == null) {
      startPoint = newKey;
    } else if (startPoint.containsKey(key)) {
      return false;
    } else {
      startPoint.addKey(key);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    this.startPoint = (KeyList<T>) startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    @SuppressWarnings("rawtypes")
    Stack toReturn = new Stack();
    if (this.startPoint == null) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else if (this.startPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (startPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else (startPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 16:30:00.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 16:30:00.208
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:03.194
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:03.197
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:03.198
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:03.797
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:03.798
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:03.799
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:04.450
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else 
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:04.451
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:04.451
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:04.551
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else 
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:04.553
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:04.553
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:07.677
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else 
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:07.678
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:07.678
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:09.155
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:09.156
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:09.157
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:09.265
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:09.266
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:09.266
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:11.204
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:11.205
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:11.205
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:11.221
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:11.221
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:11.222
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:26.041
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:26.042
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:26.042
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:26.169
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:26.170
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:26.170
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:27.307
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode.) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:27.308
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:27.308
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:27.322
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode.) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:27.323
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:27.323
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:27.598
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode.) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:27.599
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:27.599
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:28.141
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:28.142
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:28.142
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:28.302
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:28.303
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:28.303
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:30.950
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:30.951
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:30.952
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:32.605
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:32.605
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:32.606
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:34.012
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      Node<KeyListInterface<T>> currentNode = root;
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1217)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4641)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1524)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1547)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1532)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1561)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1557)
	at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:522)
	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1085)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6492)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:59)
	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:607)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6324)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:236)
	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2264)
	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2511)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6444)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5692)
	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5831)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:117)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3986)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:34.013
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1217)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4641)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1524)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1547)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1532)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1561)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1557)
	at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:522)
	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1085)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6492)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:59)
	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:607)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6324)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:236)
	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2264)
	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2511)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6444)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5692)
	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5831)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:117)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3986)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:34.014
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1217)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4641)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1524)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1547)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1532)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1561)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1557)
	at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:522)
	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1085)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6492)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:59)
	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:607)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6324)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:236)
	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2264)
	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2511)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6444)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5692)
	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5831)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:117)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3986)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:34.540
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:34.541
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:34.541
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:35.342
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:35.342
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:35.343
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:35.493
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:35.494
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:35.494
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:36.315
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:36.315
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:36.316
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:38.336
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)

      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:38.337
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:38.337
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:38.445
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)

      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:38.445
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:38.446
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:39.203
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:39.204
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:39.204
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:39.322
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:39.323
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:39.323
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:40.762
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:40.762
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:40.763
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:40.782
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(root);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:40.783
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:40.784
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:42.798
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:42.799
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:42.799
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:42.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:42.930
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:42.931
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:48.768
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:48.769
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:48.770
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:50.811
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(root);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:50.812
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:50.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:54.443
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(cu);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:54.444
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(cu);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:54.444
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:54.444
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:54.445
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:54.445
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:56.801
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:56.802
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:56.803
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:56.837
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        root = root.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:56.838
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:56.839
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:57.790
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        curren = root.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:57.791
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:57.791
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:57.809
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        curren = root.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:57.809
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:57.810
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:59.016
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = root.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:59.016
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:59.017
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:59.161
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = root.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:59.164
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:59.165
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:59.607
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = cu.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:14:59.608
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:14:59.608
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:14:59.627
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = cu.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:14:59.628
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:14:59.628
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:01.645
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:01.645
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:01.646
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:01.657
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:01.658
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:01.659
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:04.262
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:04.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:04.263
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:07.364
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:07.365
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:07.365
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:07.512
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:07.513
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:07.513
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:08.761
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.c) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:08.761
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:08.762
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:08.908
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.c) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:08.908
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:08.908
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:09.577
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(null)) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:09.577
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:09.578
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:11.520
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(sta)) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:11.521
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:11.521
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:12.843
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(s)) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:12.843
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:12.844
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:13.540
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo()) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:13.541
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:13.541
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:15.890
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint)) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:15.891
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:15.891
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:17.892
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) ) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:17.893
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:17.894
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:17.907
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) ) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:17.908
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:17.908
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:19.010
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:19.010
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:19.011
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:19.139
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:19.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:19.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:19.909
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-19 21:15:19.909
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-19 21:15:19.909
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:21.622
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:21.623
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:21.623
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:21.632
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-19 21:15:21.633
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:23.284
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:23.284
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:23.285
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:23.743
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-19 21:15:23.743
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-19 21:15:23.744
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-19 21:15:23.754
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
// --== CS400 Fall 2023 File Header Information ==--
// Name: Daniel Wang
// Email: dwang448@wisc.edu
// Group: C29
// TA: Anvay Grover
// Lecturer: Florian Heimerl

import java.util.Iterator;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import java.util.Stack;

public class IterableMultiKeyRBT<T extends Comparable<T>> extends RedBlackTree<KeyListInterface<T>>
    implements IterableMultiKeySortedCollectionInterface<T> {

  private Comparable<T> iterationStartPoint;

  private int numKey;

  /**
   * Inserts value into tree that can store multiple objects per key by keeping lists of objects in
   * each node of the tree.
   * 
   * @param key object to insert
   * @return true if a new node was inserted, false if the key was added into an existing node
   */
  @Override
  public boolean insertSingleKey(T key) {
    KeyList<T> newKey = new KeyList<T>(key);
    if (this.findNode(newKey).data.compareTo(newKey) == 0) {
      this.findNode(newKey).data.addKey(key);
      return false;
    } else {
      this.insert(newKey);
    }
    return true;
  }

  /**
   * @return the number of values in the tree.
   */
  @Override
  public int numKeys() {
    return this.numKey;
  }

  /**
   * Returns an iterator that does an in-order iteration over the tree.
   */
  @Override
  public Iterator<T> iterator() {
    // TODO Auto-generated method stub
    return null;
  }

  /**
   * Sets the starting point for iterations. Future iterations will start at the starting point or
   * the key closest to it in the tree. This setting is remembered until it is reset. Passing in
   * null disables the starting point.
   * 
   * @param startPoint the start point to set for iterations
   */
  @SuppressWarnings("unchecked")
  @Override
  public void setIterationStartPoint(Comparable<T> startPoint) {
    if (startPoint == null) {
      return;
    }
    iterationStartPoint = startPoint;
  }

  @Override
  public void clear() {
    super.clear();
    numKey = 0;
  }

  @SuppressWarnings("unchecked")
  protected Stack<T> getStartStack() {
    
    Stack<Node<KeyListInterface<T>>> toReturn = new Stack<>();
    Node<KeyListInterface<T>> currentNode = root;
    if (this.iterationStartPoint == null) { //follow the left subtree path 
      // ( in that go left every time until we reach the end)
      toReturn.push(currentNode);
      while (root.down[0] != null) {
        currentNode = currentNode.down[0];
        toReturn.push(currentNode);
      }
    } else {
      while (currentNode.data.compareTo(iterationStartPoint) != 0) {
    }
      (this.iterationStartPoint.compareTo((KeyListInterface<T>) this.root.data) > 0) {
      Node<T> root = (BinarySearchTree.Node<T>) this.root.down[1];
      toReturn.push(root);
      while (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) != 0) {
        if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) < 0) {
          root = root.down[0];
          toReturn.push(root);
        }
        else if (iterationStartPoint.compareTo((KeyListInterface<T>) root.data) > 0) {
          root = root.down[1];
          toReturn.push(root);
        }
      }
    }
    return toReturn;
  }

  /**
   * Creates an iterator for empty tree and checks if hasNext() returns false.
   */
  public void testEmptyTree() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    Assertions.assertTrue(tree.iterator().hasNext() == false);
  }

  /**
   * Inserts a single key into an empty tree, then and checks if an iterator for the tree returns
   * only this key
   */
  @Test
  public void testInitialTraversal() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(10);
    Iterator<Integer> iter = tree.iterator();
    Assertions.assertEquals(10, iter.next());
  }

  /*
   * Checks if an iterator with a start point iterates over all keys equal to and larger than the
   * start point.
   */
  @Test
  public void testIteratorOverStartPoint() {
    IterableMultiKeyRBT<Integer> tree = new IterableMultiKeyRBT<>();
    tree.insertSingleKey(5);
    tree.insertSingleKey(15);
    tree.insertSingleKey(20);

    tree.setIterationStartPoint(20);
    Assertions.assertEquals(20, tree.iterator().next());
    tree.setIterationStartPoint(10);
    Assertions.assertEquals(15, tree.iterator().next());
    tree.setIterationStartPoint(null);
    Assertions.assertEquals(5, tree.iterator().next());
  }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-19 21:15:23.755
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2273)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.294
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.334
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.372
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.419
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.443
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.483
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.556
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.605
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.655
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.720
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.751
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.771
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.799
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.822
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:37.837
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:47.296
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:05:47.403
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.685
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.714
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.731
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.749
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.765
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.781
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.796
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.811
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.827
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.849
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.883
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.918
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.939
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:06:29.956
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.098
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.138
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.184
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.212
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.254
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.282
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.305
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.370
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.410
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.442
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.469
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.498
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.544
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:25.595
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.759
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.794
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.811
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.832
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.850
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.869
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.887
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.909
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:32.927
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:33.003
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:33.024
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:33.042
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:33.062
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:33.082
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.565
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.594
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.629
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.679
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.726
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.771
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.803
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.840
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.867
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.893
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:42.970
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:43.018
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:43.068
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:07:43.091
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.316
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.348
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.376
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.406
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.433
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.460
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.486
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.533
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.561
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.585
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.610
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.628
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.654
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.684
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 14:24:38.711
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyList<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:29.096
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:29.118
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:29.134
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:29.151
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.479
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.480
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.500
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.500
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.523
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.524
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.542
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:30.542
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.778
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.779
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.811
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.812
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.830
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.830
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.865
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:09:58.866
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:19.404
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:19.405
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:19.461
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:19.461
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:26.980
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:26.981
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.347
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.347
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.365
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.366
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.384
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.384
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.403
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.404
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.426
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:36.426
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:53.813
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:10:53.813
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:07.915
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:07.915
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.890
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.890
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.911
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.913
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.932
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.933
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.949
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.949
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.965
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:23.966
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.907
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.907
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.928
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.929
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.948
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.949
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.965
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.965
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.980
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:40.981
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:51.995
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:51.996
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:52.048
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:11:52.050
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.350
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.351
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.376
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.377
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.402
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.402
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.423
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.423
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.448
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.449
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.468
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:09.469
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:14.841
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:14.842
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:32.826
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:32.826
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:32.895
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:12:32.896
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.043
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.044
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.064
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.064
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.084
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.084
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.102
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.102
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.118
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:31.119
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.225
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.226
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.246
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.246
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.266
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.267
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.285
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.285
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.301
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:13:34.301
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.932
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.933
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.951
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.952
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.969
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.970
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.985
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:33.986
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:34.000
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:34.001
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.163
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.163
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.184
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.185
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.203
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.203
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.219
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.220
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.235
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:35.236
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.282
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.283
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.298
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.298
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.311
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.312
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.331
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.332
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.353
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:36.353
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:39.961
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:39.961
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:39.982
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:39.983
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:40.006
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:40.006
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:40.029
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:40.030
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:40.049
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:40.050
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.314
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.315
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.332
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.332
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.350
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.351
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.369
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.369
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.386
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:14:49.386
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:14.739
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:14.758
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:14.777
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:14.792
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:14.812
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:17.972
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:17.972
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:17.991
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:17.992
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:18.010
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:18.010
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:18.028
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:18.028
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:18.043
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:18.043
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.279
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.279
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.298
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.298
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.317
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.318
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.336
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.336
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.352
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:27.352
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:57.988
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.023
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.043
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.061
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.078
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.221
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.221
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.240
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.240
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.258
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.258
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.275
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.276
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.291
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.291
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.558
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.558
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.576
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.577
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.594
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.594
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.611
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.611
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.626
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:58.627
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.057
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.057
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.075
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.075
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.092
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.093
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.113
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.113
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.128
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.129
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.709
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.709
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.730
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.730
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.747
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.747
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.763
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.763
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.778
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:15:59.778
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.276
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.277
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.294
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.294
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.310
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.310
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.341
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.341
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.356
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:00.356
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.582
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.583
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.615
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.615
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.640
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.640
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.658
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.659
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.676
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:04.676
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.898
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.898
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.919
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.919
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.937
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.937
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.952
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.952
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.966
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:05.967
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.602
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.602
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.622
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.623
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.642
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.643
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.662
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.662
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.679
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:06.679
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:11.979
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:11.979
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:11.998
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:11.998
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:12.018
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:12.019
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:12.038
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:12.038
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:12.054
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:12.054
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.224
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.224
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.242
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.242
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.260
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.260
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.278
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.278
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.293
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:16:13.293
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:17:23.593
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:17:23.613
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:17:23.628
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>

!ENTRY org.eclipse.debug.core 2 0 2023-10-20 16:17:23.654
!MESSAGE Compile error during code evaluation: Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type KeyListInterface<T>
